/*
  LedControl.h - A library for controling Leds with a ICM7218/ICM7228
  Copyright (c) 2010 Mike Hogan / PJ Santoro / Hive76

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <WProgram.h>
#include "ICM7228.h"

ICM7228::ICM7228(){
  int i;
  for(int i=0; i < 8; i++){
      _buffer[i]=0;
  }
  
  pinMode(COL_1, OUTPUT);
  pinMode(COL_2, OUTPUT);
  pinMode(COL_3, OUTPUT);
  pinMode(COL_4, OUTPUT);
  pinMode(COL_5, OUTPUT);
  pinMode(COL_6, OUTPUT);
  pinMode(COL_7, OUTPUT);
  pinMode(COL_8, OUTPUT);
  pinMode(NOT_WRITE_PIN, OUTPUT);
  pinMode(MODE_PIN, OUTPUT);
}

byte ICM7228::_font[][8]={
	{0x00, 0x7C, 0xC6, 0xCC, 0xC6, 0xDC, 0x00, 0x00},	// Char 000 (beta)
    {0x00, 0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x00, 0x00},	// Char 001 (A)
    {0x00, 0xFC, 0xC6, 0xFE, 0xC6, 0xFC, 0x00, 0x00},	// Char 002 (B)
    {0x00, 0x7E, 0xC0, 0xC0, 0xC0, 0x7E, 0x00, 0x00},	// Char 003 (C)
    {0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00, 0x00},	// Char 004 (D)
    {0x00, 0xFE, 0xC0, 0xF8, 0xC0, 0xFE, 0x00, 0x00},	// Char 005 (E)
    {0x00, 0xFE, 0xC0, 0xF8, 0xC0, 0xC0, 0x00, 0x00},	// Char 006 (F)
    {0x00, 0x7E, 0xC0, 0xCE, 0xC6, 0x7E, 0x00, 0x00},	// Char 007 (G)
    {0x00, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 0x00},	// Char 008 (H)
    {0x00, 0x7E, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00},	// Char 009 (I)
    {0x00, 0x0E, 0x06, 0x06, 0x0E, 0x7C, 0x00, 0x00},	// Char 010 (J)
    {0x00, 0xC6, 0xCC, 0xF8, 0xCC, 0xC6, 0x00, 0x00},	// Char 011 (K)
    {0x00, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, 0x00},	// Char 012 (L)
    {0x00, 0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0x00, 0x00},	// Char 013 (M)
    {0x00, 0xC6, 0xF6, 0xFE, 0xDE, 0xC6, 0x00, 0x00},	// Char 014 (N)
    {0x00, 0x38, 0xC6, 0xC6, 0xC6, 0x38, 0x00, 0x00},	// Char 015 (O)
    {0x00, 0xFC, 0xC6, 0xFC, 0xC0, 0xC0, 0x00, 0x00},	// Char 016 (P)
    {0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0x7C, 0x0C, 0x00},	// Char 017 (Q)
    {0x00, 0xFC, 0xC6, 0xFE, 0xCC, 0xC6, 0x00, 0x00},	// Char 018 (R)
    {0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00, 0x00},	// Char 019 (S)
    {0x00, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00},	// Char 020 (T)
    {0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00},	// Char 021 (U)
    {0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00},	// Char 022 (V)
    {0x00, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00, 0x00},	// Char 023 (W)
    {0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 0x00},	// Char 024 (X)
    {0x00, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x00},	// Char 025 (Y)
    {0x00, 0xFE, 0x0E, 0x38, 0xE0, 0xFE, 0x00, 0x00},	// Char 026 (Z)
    {0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C},	// Char 027 ([)
    {0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C},	// Char 028 (])
    {0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 0x00},	// Char 029 (!)
    {0x00, 0x36, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 030 (")
    {0x00, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 031 (')
    {0x0E, 0x1C, 0x38, 0x30, 0x30, 0x38, 0x1C, 0x0E},	// Char 032 (()
    {0x70, 0x38, 0x1C, 0x0C, 0x0C, 0x1C, 0x38, 0x70},	// Char 033 ())
    {0x08, 0x4A, 0x2C, 0xE0, 0x07, 0x34, 0x52, 0x10},   // Char 034 (*)
    {0x00, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x00, 0x00},	// Char 035 (+)
    {0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00, 0x00},	// Char 036 (,)
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},	// Char 037 (-)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x18, 0x00},	// Char 038 (.)
    {0x00, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06},	// Char 039 (\)
    {0x00, 0x7C, 0xE6, 0xEE, 0xF6, 0xFE, 0xFE, 0x7C},	// Char 040 (0)
    {0x00, 0x38, 0x78, 0x38, 0x38, 0xFE, 0xFE, 0xFE},	// Char 041 (1)
    {0x00, 0x7C, 0xCE, 0x1C, 0x78, 0xFE, 0xFE, 0xFE},	// Char 042 (2)
    {0x00, 0x7E, 0x06, 0x1C, 0xC6, 0xFE, 0xFE, 0x7C},	// Char 043 (3)
    {0x00, 0x1C, 0x3C, 0x7C, 0xDC, 0xFE, 0xFE, 0x1C},	// Char 044 (4)
    {0x00, 0xFE, 0xE0, 0xFC, 0x06, 0xE6, 0xFE, 0x7C},	// Char 045 (5)
    {0x00, 0xFE, 0xC0, 0xFE, 0xC6, 0xFE, 0x00, 0x00},	// Char 046 (6)
    {0x00, 0xFE, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00},	// Char 047 (7)
    {0x00, 0x7C, 0xEE, 0x7C, 0xEE, 0xFE, 0xFE, 0x7C},	// Char 048 (8)
    {0x00, 0x7C, 0xE6, 0x7E, 0x0E, 0xFE, 0xFC, 0xF8},	// Char 049 (9)
    {0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00},	// Char 050 (:)
    {0x00, 0x3C, 0x6E, 0x6E, 0x0C, 0x00, 0x18, 0x18},	// Char 051 (?)
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},	// Char 052 (Sp)
};

void ICM7228::writeDot(uint8_t row, uint8_t col, boolean dot)
{
  uint8_t rowOr =  dot << col;
  uint8_t rowAnd =  ~(0x80 << col);
  _buffer[row] =  (_buffer[row] & rowAnd) | rowOr;
}
    
void ICM7228::writeRow(uint8_t row, uint8_t dots){
	_buffer[row] =  dots;
}

void ICM7228::writeCol(uint8_t col, uint8_t dots){
  uint8_t colBit =  (0x80 >> (col-1));             // Creates a byte with a 1 in the corresponding "column." ex. if col = 3, then colBit = 00100000
  int colBitNum = 0;                               // Tells which bit in the colBit byte is "on." ex. if col = 3, then colBit = 0010000, and colBitNum = 5

    for (boolean y = 0; y != 1; colBitNum++){      // Reads through colBit to figure out the (bit number of "on" bit + 1)
    y = ((colBit >> colBitNum) & 0x01);
  }

  for (int x = 0; x < 8; x++){
    int yy = ((dots << x) & 0x80);
    _buffer[x] = (yy >> (col-1));
  }
}

void ICM7228::scroll(uint8_t letter){
  
  for (int i = 0; i < 8; i++){
    controlWord();
    
    for (int ii = 0; ii < 8; ii++){
      if (((_font[letter][ii] << i) & 0x80) == 0){
        _buffer[ii] &= ~(1 << 0);
      }
      else {
        _buffer[ii] |= (1 << 0);
      }
      writeRow(ii, _buffer[ii]);
      _buffer[ii] <<= 1;      
    }
    
    refresh();
    delay(50);
  }
 }

void ICM7228::refresh()
{
	for (int ii = 0; ii < 8; ii++){
		digitalWrite(NOT_WRITE_PIN, LOW);

		digitalWrite(COL_1, _buffer[ii] & 0x80);
		digitalWrite(COL_2, _buffer[ii] & 0x40); 
		digitalWrite(COL_3, _buffer[ii] & 0x20);
		digitalWrite(COL_4, _buffer[ii] & 0x10);
		digitalWrite(COL_5, _buffer[ii] & 0x08);
		digitalWrite(COL_6, _buffer[ii] & 0x04);
		digitalWrite(COL_7, _buffer[ii] & 0x02);
		digitalWrite(COL_8, !(_buffer[ii] & 0x01));

		digitalWrite(NOT_WRITE_PIN, HIGH);
	}      
}

void ICM7228::controlWord()
{
  // Control Mode
  digitalWrite(NOT_WRITE_PIN, HIGH);
  digitalWrite(MODE_PIN, HIGH);

  // Setup control word
  digitalWrite(NOT_SHUTDOWN_PIN, HIGH);  // Normal mode
  digitalWrite(NOT_DECODE_PIN, HIGH);    // No Decode mode
  digitalWrite(NOT_CODE_B_PIN, LOW);     // Not actually being used, just setting to known state
  digitalWrite(DATA_COMING_PIN, HIGH);   // The data to display will follow

  // Write the control word
  digitalWrite(NOT_WRITE_PIN, LOW);
  digitalWrite(NOT_WRITE_PIN, HIGH);

  //get ready to load Display RAM
  digitalWrite(MODE_PIN, LOW);
}